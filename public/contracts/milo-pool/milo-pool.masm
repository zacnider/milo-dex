use.miden::active_account
use.miden::native_account
use.miden::output_note

#! CONSTANTS
const.MAX_COVERAGE_RATIO = 0x0002 # 200%

#! ERRORS
const.ERR_MAX_COVERAGE_RATIO_EXCEEDED ="Max coverage ratio exceeded"
const.ERR_RESERVE_WITH_SLIPPAGE_EXCEEDS_ASSET_BALANCE ="Reserve with slippage exceeds asset balance"
const.ERR_RESERVE_EXCEEDS_RESERVE_WITH_SLIPPAGE ="Reserve exceeds reserve with slippage"
const.ERR_LP_WITHDRAW_AMOUNT_EXCEEDS_USER_LP_SHARES ="LP withdrawal amount exceeds user LP shares"

#! MEM STRUCTURE
#! DYNAMIC PROC ADDRESS
const.DYNAMIC_PROC_ADDR = 0x0004

const.DEPOSIT_ASSET_LOC = 0x00A0
const.DEPOSIT_KEY_LOC = 0x00A4
const.WITHDRAW_KEY_LOC = 0x00A4
const.BOUNCE_ASSET_LOC = 0x00A8
const.LP_SHARES_LOC = 0x00AC
const.LP_SHARES_AMOUNT_ADDR = LP_SHARES_LOC + 3

#! STORAGE STRUCTURE
#! pool state: [liabilities, reserve, reserve_with_slippage, 0]
#! fees: [swap_fee, backstop_fee, protocol_fee, 0 ]
const.ASSETS_MAPPING_SLOT = 0x0002
const.POOL_STATE_MAPPING_SLOT = 0x0003
const.USER_DEPOSITS_MAPPING_SLOT = 0x0004
const.POOL_CURVE_MAPPING_SLOT = 0x0005
const.POOL_FEES_MAPPING_SLOT = 0x0006

#! INDEXES
const.LIABILITIES_INDEX = 0x0000
const.RESERVE_INDEX = 0x0001
const.RESERVE_WITH_SLIPPAGE_INDEX = 0x0002
const.SWAP_FEE_INDEX = 0x0000
const.BACKSTOP_FEE_INDEX = 0x0001
const.PROTOCOL_FEE_INDEX = 0x0002
const.C_INDEX = 0x0000
const.BETA_INDEX = 0x0001

#! Sets POOL STATE
#!
#! Inputs: [ASSET, liabilities, reserve, reserve_with_slippage]
#! Outputs: []
export.set_pool_state
    dupw
    movdnw.2
    # =>[ASSET, liabilities, reserve, reserve_with_slippage, 0,ASSET]

    # @dev: ensure reserve never > reserve_with_slippage
    dup.5  
    # =>[reserve, ASSET, liabilities, reserve, reserve_with_slippage, 0, ASSET]
    dup.7
    # => [reserve_with_slippage, reserve, ASSET, liabilities, reserve, reserve_with_slippage, 0, ASSET]
    lte assert.err=ERR_RESERVE_EXCEEDS_RESERVE_WITH_SLIPPAGE
    ## => [ASSET, liabilities, reserve, reserve_with_slippage, 0, ASSET]

    # @dev:ensure reserves < max_coverage_ratio * liabilities
    dup.6 dup.5 mul.MAX_COVERAGE_RATIO
    # => [liablities * max_coverage_ratio, reserve_with_slippage, ASSET, liabilities, reserve, reserve_with_slippage, 0, ASSET]
    lt assert.err=ERR_MAX_COVERAGE_RATIO_EXCEEDED
    ## => [ASSET, liabilities, reserve, reserve_with_slippage, 0, ASSET]

    # => [ASSET, liabilities, reserve, reserve_with_slippage, 0, ASSET]
    
    exec.address_from_asset
    # => [asset_faucet_id_prefix, asset_faucet_id_suffix, liabilities, reserve, reserve_with_slippage, 0, ASSET]
    exec.active_account::get_balance
    # => [asset_balance, liabilities, reserve, reserve_with_slippage, 0, ASSET]

    dup.3 swap
    # => [asset_balance, reserve_with_slippage, pool_state_loc, liabilities, reserve, reserve_with_slippage, 0, ASSET]
    lte assert.err=ERR_RESERVE_WITH_SLIPPAGE_EXCEEDS_ASSET_BALANCE
    # => [liabilities, reserve, reserve_with_slippage, 0, ASSET]
    # => [ POOL_STATE, ASSET]
    swapw 
    # => [ ASSET, POOL_STATE]
    #reversew drop drop push.0.0
    exec.address_word_from_asset
    
    # => [asset_faucet_id_prefix, asset_faucet_id_suffix, 0, 0, POOL_STATE]
    # => [POOL_KEY, POOL_STATE]
    push.POOL_STATE_MAPPING_SLOT
    exec.native_account::set_map_item
    
    dropw dropw
    # => []  
end

#! Returns POOL STATE
#!
#! Inputs: [ASSET]
#! Outputs: [liabilities, reserve, reserve_with_slippage, 0]
export.get_pool_state
    exec.address_word_from_asset
    push.POOL_STATE_MAPPING_SLOT
    exec.active_account::get_map_item
    swapw dropw
    # => [liabilities, reserve, reserve_with_slippage]
end

#! Returns POOL ASSET ID
#!
#! Inputs: [pool_index]
#! Outputs: [asset_id_prefix, asset_id_suffix]
export.get_pool_asset
    push.0.0.0 
    push.ASSETS_MAPPING_SLOT
    exec.active_account::get_map_item
    swap.2 drop
    swap.2 drop
end

# WALLET FUNCTIONS

#! Adds the provided asset to the active account.
#!
#! Inputs:  [ASSET, reserve, reserve_with_slippage, liabilities, 0, pad(8)]
#! Outputs: [pad(16)]
#!
#! Where:
#! - ASSET is the asset to be received, can be fungible or non-fungible
#!
#! Panics if:
#! - the same non-fungible asset already exists in the account.
#! - adding a fungible asset would result in amount overflow, i.e.,
#!   the total amount would be greater than 2^63.
#!
#! Invocation: call
export.receive_asset
    exec.native_account::add_asset
    # => [ASSET', reserve, reserve_with_slippage, liabilities, 0, pad(8)]

    procref.validate_and_update_state mem_storew_be.DYNAMIC_PROC_ADDR dropw push.DYNAMIC_PROC_ADDR
    dynexec

    # => [pad(16)]
end

proc.validate_and_update_state
   exec.set_pool_state
end

#! add new deposit: receive asset, update deposit mapping
#!
#! Inputs: [ASSET, POOL_STATE,user_id_suffix, user_id_prefix, lp_amount_out]
#! Outputs: [share_amount]
export.deposit
    mem_storew_be.DEPOSIT_ASSET_LOC
    exec.receive_asset
    padw mem_loadw_be.DEPOSIT_ASSET_LOC
    exec.get_user_deposit_key
    mem_storew_be.DEPOSIT_KEY_LOC
    movup.4
    dup mem_store.LP_SHARES_AMOUNT_ADDR
    push.0.0.0
    swapw
    push.USER_DEPOSITS_MAPPING_SLOT 
    exec.add_to_map_item
    mem_load.LP_SHARES_AMOUNT_ADDR push.0.0.0
    padw mem_loadw_be.DEPOSIT_KEY_LOC
    exec.get_lp_shares_total_supply_key
    push.USER_DEPOSITS_MAPPING_SLOT
    exec.add_to_map_item
end

#! Inputs: [slot, KEY, VALUE]
proc.add_to_map_item
    movdn.4 dupw movup.8 dup movdn.5
    exec.active_account::get_map_item drop drop drop
    movup.9 add
    movdn.8
    exec.native_account::set_map_item dropw dropw
end

#! Returns user LP shares amount
proc.get_user_deposit
    push.USER_DEPOSITS_MAPPING_SLOT
    exec.active_account::get_map_item 
    drop drop drop
end

#! Returns user LP shares mapping key
proc.get_user_deposit_key
    exec.address_from_asset
end

#! Returns LP shares total supply key
proc.get_lp_shares_total_supply_key
    exec.address_word_from_asset
end

#! UTILS
proc.address_word_from_asset
    push.0 swap.3 drop
    push.0 swap.4 drop
end

proc.address_from_asset
    swap.2 drop
    swap.2 drop
end

#! Adds the provided asset to an output note.
#!
#! Inputs:  [ASSET, noteid, 0,0,0, liabilities, reserve, reserve_with_slippage, 0, pad(4)]
#! Outputs: [pad(16)]
#!
export.move_asset_to_note
    exec.native_account::remove_asset
    # => [ASSET, note_idx, 0,0,0, liabilities, reserve, reserve_with_slippage, 0, pad(4)]

    dupw dup.8 movdn.4
    # => [ASSET, note_idx, ASSET, note_idx,0,0,0, liabilities, reserve, reserve_with_slippage, 0, pad(4)]

    exec.output_note::add_asset
    
    # => [ASSET, note_idx, 0,0,0, liabilities, reserve, reserve_with_slippage, 0, pad(4)]

    swapw.1 dropw 
    
    exec.set_pool_state
end

#! Bounce asset back to sender (if swap fails)
#!
#! Inputs:  [ASSET, noteid]
#! Outputs: [pad(16)]
#!
export.bounce_asset
    mem_storew_be.BOUNCE_ASSET_LOC
    exec.native_account::add_asset
    dropw
    mem_loadw_be.BOUNCE_ASSET_LOC
    exec.native_account::remove_asset
    
    exec.output_note::add_asset
end
