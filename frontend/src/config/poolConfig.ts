// Pool Account IDs for Milo Swap Protocol v0.13
// Auto-generated by add_liquidity script
// Pool accounts created with BasicWallet component

export const MILO_MUSDC_POOL_ACCOUNT_ID_HEX = '0x70e4a5ff036fe21004c953d8b7c99c';
export const MELO_MUSDC_POOL_ACCOUNT_ID_HEX = '0x02db2e36774d1f107f406d62dffb74';

// Get pool account ID hex for a specific token pair
export function getPoolAccountIdHex(tokenA: string, tokenB: string): string {
  const pair = `${tokenA}/${tokenB}`;
  if (pair === 'MILO/MUSDC' || pair === 'MUSDC/MILO') {
    return MILO_MUSDC_POOL_ACCOUNT_ID_HEX;
  } else if (pair === 'MELO/MUSDC' || pair === 'MUSDC/MELO') {
    return MELO_MUSDC_POOL_ACCOUNT_ID_HEX;
  }
  return MILO_MUSDC_POOL_ACCOUNT_ID_HEX;
}

// Get default pool account ID hex
export function getDefaultPoolAccountIdHex(): string {
  return MILO_MUSDC_POOL_ACCOUNT_ID_HEX;
}

// Backward compatibility functions
export function getMiloMusdcPoolAccountId(): string {
  return MILO_MUSDC_POOL_ACCOUNT_ID_HEX;
}

export function getMeloMusdcPoolAccountId(): string {
  return MELO_MUSDC_POOL_ACCOUNT_ID_HEX;
}

export function getPoolAccountIdForPair(tokenA: string, tokenB: string): string {
  return getPoolAccountIdHex(tokenA, tokenB);
}

// Legacy constant for backward compatibility
export const POOL_ACCOUNT_ID = MILO_MUSDC_POOL_ACCOUNT_ID_HEX;

// Pool configurations
export const POOLS = [
  {
    pair: 'MILO/MUSDC',
    tokenA: 'MILO',
    tokenB: 'MUSDC',
    poolAccountIdHex: MILO_MUSDC_POOL_ACCOUNT_ID_HEX,
  },
  {
    pair: 'MELO/MUSDC',
    tokenA: 'MELO',
    tokenB: 'MUSDC',
    poolAccountIdHex: MELO_MUSDC_POOL_ACCOUNT_ID_HEX,
  },
];

// Multi-hop routing
export interface SwapRoute {
  path: string[];       // e.g. ['MILO', 'MUSDC', 'MELO']
  pools: string[];      // pool hex IDs for each hop
  hops: number;
  isDirect: boolean;
}

// Internal helper - returns pool hex ID if pair exists, null otherwise
function getPoolForPair(tokenA: string, tokenB: string): string | null {
  const pair1 = `${tokenA}/${tokenB}`;
  const pair2 = `${tokenB}/${tokenA}`;
  for (const pool of POOLS) {
    if (pool.pair === pair1 || pool.pair === pair2) {
      return pool.poolAccountIdHex;
    }
  }
  return null;
}

// Find the best route for a swap (direct or multi-hop via MUSDC)
export function findSwapRoute(sellToken: string, buyToken: string): SwapRoute | null {
  if (sellToken === buyToken) return null;

  // Direct route
  const directPool = getPoolForPair(sellToken, buyToken);
  if (directPool) {
    return {
      path: [sellToken, buyToken],
      pools: [directPool],
      hops: 1,
      isDirect: true,
    };
  }

  // Multi-hop via MUSDC (hub token)
  if (sellToken !== 'MUSDC' && buyToken !== 'MUSDC') {
    const hop1Pool = getPoolForPair(sellToken, 'MUSDC');
    const hop2Pool = getPoolForPair('MUSDC', buyToken);
    if (hop1Pool && hop2Pool) {
      return {
        path: [sellToken, 'MUSDC', buyToken],
        pools: [hop1Pool, hop2Pool],
        hops: 2,
        isDirect: false,
      };
    }
  }

  return null;
}

// Calculate estimated output for a multi-hop swap
export function estimateMultiHopOutput(
  route: SwapRoute,
  amountIn: bigint,
  poolReserves: Record<string, { reserveA: bigint; reserveB: bigint }>,
): { estimatedOut: bigint; intermediateAmount?: bigint } | null {
  if (route.isDirect) return null; // Use normal estimation for direct routes

  // Hop 1: sellToken -> MUSDC
  const hop1Pair = `${route.path[0]}/MUSDC`;
  const hop1PairReverse = `MUSDC/${route.path[0]}`;
  const hop1Reserves = poolReserves[hop1Pair] || poolReserves[hop1PairReverse];
  if (!hop1Reserves || hop1Reserves.reserveA <= BigInt(0) || hop1Reserves.reserveB <= BigInt(0)) return null;

  // Determine reserve direction for hop 1
  let reserveIn1: bigint, reserveOut1: bigint;
  const pool1Config = POOLS.find(p => p.poolAccountIdHex === route.pools[0]);
  if (pool1Config && pool1Config.tokenA === route.path[0]) {
    reserveIn1 = hop1Reserves.reserveA;
    reserveOut1 = hop1Reserves.reserveB;
  } else {
    reserveIn1 = hop1Reserves.reserveB;
    reserveOut1 = hop1Reserves.reserveA;
  }

  // AMM for hop 1 (0.1% fee)
  const fee = BigInt(1000);
  const amountInWithFee1 = amountIn * (BigInt(1000000) - fee);
  const intermediateAmount = (amountInWithFee1 * reserveOut1) / (reserveIn1 * BigInt(1000000) + amountInWithFee1);

  // Hop 2: MUSDC -> buyToken
  const hop2Pair = `${route.path[2]}/MUSDC`;
  const hop2PairReverse = `MUSDC/${route.path[2]}`;
  const hop2Reserves = poolReserves[hop2Pair] || poolReserves[hop2PairReverse];
  if (!hop2Reserves || hop2Reserves.reserveA <= BigInt(0) || hop2Reserves.reserveB <= BigInt(0)) return null;

  // Determine reserve direction for hop 2 (MUSDC -> buyToken)
  let reserveIn2: bigint, reserveOut2: bigint;
  const pool2Config = POOLS.find(p => p.poolAccountIdHex === route.pools[1]);
  if (pool2Config && pool2Config.tokenB === 'MUSDC') {
    // pool is buyToken/MUSDC, selling MUSDC means MUSDC is tokenB (reserveB)
    reserveIn2 = hop2Reserves.reserveB;
    reserveOut2 = hop2Reserves.reserveA;
  } else {
    reserveIn2 = hop2Reserves.reserveA;
    reserveOut2 = hop2Reserves.reserveB;
  }

  // AMM for hop 2 (0.1% fee)
  const amountInWithFee2 = intermediateAmount * (BigInt(1000000) - fee);
  const estimatedOut = (amountInWithFee2 * reserveOut2) / (reserveIn2 * BigInt(1000000) + amountInWithFee2);

  return { estimatedOut, intermediateAmount };
}
