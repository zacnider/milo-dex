use.miden::active_note
use.miden::output_note
use.std::crypto::hashes::rpo
use.std::sys

# Note: milopool library will be linked at runtime
# The pool account exports these functions:
# - receive_asset
# - bounce_asset
# - move_asset_to_note

# ERROR
const.ERR_SWAP_WRONG_NUMBER_OF_INPUTS="SWAP wrong number of inputs"
const.ERR_SWAP_WRONG_NUMBER_OF_ASSETS="SWAP wrong number of assets"

# CONSTANTS
const.PUBLIC_NOTE=1
const.EXECUTION_HINT_ALWAYS=1

# MEMORY
const.INPUTS_POINTER = 0x0010
const.INPUTS_WORD_0 = INPUTS_POINTER        # [min_amount_out, empty, out_asset_id_suffix, out_asset_id_prefix]
const.INPUTS_WORD_1 = INPUTS_POINTER + 4    # [deadline, p2id_tag, empty, empty]
const.INPUTS_WORD_2 = INPUTS_POINTER + 8    # [CREATOR_ID_WORD] = [empty, empty, creator_id_suffix, creator_id_prefix]
const.NUMBER_OF_INPUTS = 0x000C # 12

# semantic names for inputs
const.MIN_AMOUNT_OUT = INPUTS_WORD_0  # 0x0010
const.OUT_TOKEN_EMPTY_FELT = INPUTS_WORD_0 + 1
const.OUT_TOKEN_ID_SUFFIX = INPUTS_WORD_0 + 2
const.OUT_TOKEN_ID_PREFIX = INPUTS_WORD_0 + 3  # 0x0013

# [deadline, p2id_tag, empty, empty]
const.DEADLINE = INPUTS_WORD_1  # 0x0014
const.P2ID_TAG = INPUTS_WORD_1 + 1
const.EMPTY_INPUT_6 = INPUTS_WORD_1 + 2
const.EMPTY_INPUT_7 = INPUTS_WORD_1 + 3  # 0x0017

# [empty, empty, creator_id_suffix, creator_id_prefix]
const.EMPTY_INPUT_8 = INPUTS_WORD_2 # 0x0018
const.EMPTY_INPUT_9 = INPUTS_WORD_2 + 1
const.SWAP_CREATOR_ID_SUFFIX = INPUTS_WORD_2 + 2
const.SWAP_CREATOR_ID_PREFIX = INPUTS_WORD_2 + 3  # 0x001B

# argument memory 4 WORDS 
# 0x0040 - 0x004F
const.ARGS_POINTER = 0x0040
const.ARGS_WORD_0 = ARGS_POINTER        # [total_liabilities_in, reserve_in, reserve_with_slippage_in, amount_out]
const.ARGS_WORD_1 = ARGS_POINTER + 4    # [total_liabilities_out, reserve_out, reserve_with_slippage_out, 0]
const.NUMBER_OF_ARGS = 0x0008 # 8

# semantic names for args
const.NEW_IN_POOL_STATE_WORD = ARGS_WORD_0  # 0x0040
const.NEW_OUT_POOL_STATE_WORD = ARGS_WORD_1  # 0x0044

# [amount_out]
const.AMOUNT_OUT = ARGS_WORD_0 + 3

# [pool_in_liabilities, pool_in_reserve, pool_in_reserve_with_slippage, amount_out]
const.IN_POOL_LIABILITIES = NEW_IN_POOL_STATE_WORD  # 0x0040
const.IN_POOL_RESERVE = NEW_IN_POOL_STATE_WORD + 1
const.IN_POOL_RESERVE_WITH_SLIPPAGE = NEW_IN_POOL_STATE_WORD + 2

# [pool_out_liabilities, pool_out_reserve, pool_out_reserve_with_slippage, empty]
const.OUT_POOL_LIABILITIES = NEW_OUT_POOL_STATE_WORD  # 0x0044
const.OUT_POOL_RESERVE = NEW_OUT_POOL_STATE_WORD + 1
const.OUT_POOL_RESERVE_WITH_SLIPPAGE = NEW_OUT_POOL_STATE_WORD + 2
const.OUT_POOL_EMPTY_FELT = NEW_OUT_POOL_STATE_WORD + 3

# memory addresses of the assets
const.IN_ASSET_WORD = 0x0060
const.AMOUNT_IN = IN_ASSET_WORD
const.IN_TOKEN_EMPTY_FELT = IN_ASSET_WORD + 1
const.IN_TOKEN_ID_PREFIX = IN_ASSET_WORD + 3
const.IN_TOKEN_ID_SUFFIX = IN_ASSET_WORD + 2

# "constant" MEMORY
const.P2ID_SCRIPT_ROOT_WORD = 0x0080

proc.store_asset_in_to_memory
    push.IN_ASSET_WORD exec.active_note::get_assets assert.err=ERR_SWAP_WRONG_NUMBER_OF_ASSETS
    drop
end

proc.store_inputs_to_memory
    # store note inputs into memory starting at address 0
    push.INPUTS_POINTER exec.active_note::get_inputs
    # => [num_inputs, inputs_ptr]
    # make sure the number of inputs is N
    eq.NUMBER_OF_INPUTS assert.err=ERR_SWAP_WRONG_NUMBER_OF_INPUTS
    # => [inputs_ptr]
    drop
end

# @note TODO: pool stats will likely need to go through the advice stack
proc.store_args_to_memory
    # Args will be provided by pool contract via advice stack
    # For now, we'll use the serial number to fetch from advice map
    exec.active_note::get_serial_number
    adv.push_mapval
    swap.3 drop push.ARGS_POINTER
    padw padw padw
    adv_pipe
    dropw swapw dropw swapw dropw
end

#! Returns the P2ID RECIPIENT for a specified SERIAL_NUM, SCRIPT_HASH, and account_id
proc.build_p2id_recipient_hash
    padw hmerge
    # => [SERIAL_NUM_HASH, SCRIPT_HASH]
    swapw hmerge
    # => [SERIAL_SCRIPT_HASH]
    padw
    mem_load.SWAP_CREATOR_ID_SUFFIX mem_load.SWAP_CREATOR_ID_PREFIX
    push.0.0

    push.4000 mem_storew_be dropw
    push.4004 mem_storew_be dropw

    push.8.4000
    # => [ptr, elements]
    exec.rpo::hash_memory
    # => [INPUTS_HASH, SERIAL_SCRIPT_HASH]
    hmerge
    # => [P2ID_RECIPIENT]
end

# input: [SERIAL_NUM,...]
# output: [P2ID_SERIAL_NUM, ...]
proc.get_p2id_serial_num
    add.1
end

#! Creates a P2ID note to creator
proc.create_p2id_reverse_note
    padw padw
    # => [pad(8), ASSET_TO_BE_SENT]
    padw mem_loadw_be.P2ID_SCRIPT_ROOT_WORD
    # => [P2ID_SCRIPT_HASH, pad(8), ASSET_TO_BE_SENT]
    exec.active_note::get_serial_number
    # => [P2ID_SERIAL_NUM, P2ID_SCRIPT_HASH, pad(8), ASSET_TO_BE_SENT]
    exec.get_p2id_serial_num
    # => [P2ID_SERIAL_NUM, P2ID_SCRIPT_HASH, pad(8), ASSET_TO_BE_SENT]
    exec.build_p2id_recipient_hash
    # => [P2ID_RECIPIENT, pad(8), ASSET_TO_BE_SENT]

    push.EXECUTION_HINT_ALWAYS
    # => [execution_hint_always, P2ID_RECIPIENT, pad(8), ASSET_TO_BE_SENT]
    push.PUBLIC_NOTE
    # => [public_note, execution_hint_always, P2ID_RECIPIENT, pad(8), ASSET_TO_BE_SENT]
    push.0 # aux for p2id output note
    # => [aux, public_note, execution_hint_always, P2ID_RECIPIENT, pad(8), ASSET_TO_BE_SENT]
    mem_load.P2ID_TAG
    # => [tag, aux, public_note, execution_hint_always, P2ID_RECIPIENT, pad(8), ASSET_TO_BE_SENT]
    call.output_note::create
    # => [note_idx, pad(15), ASSET_TO_BE_SENT]
    swapw.2 dropw swapw.3
    # => [ASSET, note_idx, pad(11)]
end

proc.store_p2id_script_hash
    push.15783632360113277539.7403765918285273520.15691985194755641846.10399643920503194563
    mem_storew_be.P2ID_SCRIPT_ROOT_WORD dropw
end

proc.execute_SWAP
    mem_load.AMOUNT_OUT
    mem_load.MIN_AMOUNT_OUT
    lt
    # min amount out is not met
    if.true
        mem_loadw_be.IN_ASSET_WORD
        exec.create_p2id_reverse_note
        # Bounce asset back to creator if min amount not met
        # Note: bounce_asset will be called by pool contract
    else
        # Receive input asset into pool
        mem_load.IN_POOL_RESERVE_WITH_SLIPPAGE mem_load.IN_POOL_RESERVE mem_load.IN_POOL_LIABILITIES
        push.0.0.0.0
        mem_loadw_be.IN_ASSET_WORD
        # Call pool's receive_asset procedure
        # Note: This will be dynamically linked at runtime

        # Create P2ID note with output asset
        mem_load.AMOUNT_OUT push.0 mem_load.OUT_TOKEN_ID_SUFFIX mem_load.OUT_TOKEN_ID_PREFIX
        exec.create_p2id_reverse_note

        # Update pool state
        padw mem_loadw_le.NEW_OUT_POOL_STATE_WORD # load new out pool state
        swapw.2 swapw 

        # Move asset to note
        # Note: move_asset_to_note will be called by pool contract
    end
end

begin
    exec.store_args_to_memory
    exec.store_inputs_to_memory
    exec.store_asset_in_to_memory

    exec.store_p2id_script_hash
    exec.execute_SWAP

    exec.sys::truncate_stack
end
